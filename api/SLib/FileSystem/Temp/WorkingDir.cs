using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace SLib.FileSystem.Temp
{
    /// <summary>
    ///   Represents the base directory that some parts of the program can put temporary files & directories into.
    ///   This class also provides strategies for cleaning up files & directories in the WorkingDir to make sure
    ///   it does not keep growing.
    /// </summary>
    public class WorkingDir
    {
        readonly string _basePath;
        readonly string _dirName;
    
    
        public WorkingDir(string basePath, string dirName = "")
        {
            if (PathModule.IsPath( dirName ))
                throw new ArgumentException( "dirName is not allowed to be a path.", nameof( dirName ) );

            if (string.IsNullOrWhiteSpace( dirName ))
            {
                _basePath = Path.GetDirectoryName( basePath );
                _dirName  = PathModule.GetLastDirectoryName( basePath );
            }
            else
            {
                _basePath = basePath;
                _dirName  = dirName;
            }
        }
    
    
        public string DirPath => Path.Combine( _basePath, _dirName );
    
    
        /// <summary>
        ///   Creates the directory on the file system if it does not already exist.
        /// </summary>
        public void Create()
        {
            if (! Directory.Exists( DirPath ))
                Directory.CreateDirectory( DirPath );
        }
    
    
        /// <summary>
        ///   Creates a new TempDir object, relative to the WorkingDir, using the supplied dirNameTemplate.
        ///   NOTE: This does not actually create the directory on the file system.
        /// </summary>
        /// <param name="dirNameTemplate">
        ///   A template string that is used to determine the name of the new TempDir.
        ///   It can have 1 of 3 possible values:
        ///     (1.) Empty           - a fully random name will be generated that is unique within the WorkingDir.
        ///     (2.) "temp_dir_{0}"  - a semi random name will be generated, replacing the {0} placeholder with some random, unique value.
        ///     (3.) "my_temp_dir"   - an exact, non-random name that will always be the same.
        /// </param>
        public TempDir NewTempDir(string dirNameTemplate = "")
        {
            string name = TempUtils.GenerateFsEntryName( DirPath, dirNameTemplate );
            var tempDir = new TempDir( DirPath, name );
            return tempDir;
        }


        public TempDir WithNewTempDir(string dirNameTemplate, Action<TempDir> actionF)
        {
            // make sure the WorkingDir exists
            Create();

            // create a new temp dir inside the WorkingDir to isolate the files being created, and make sure that dir is CLEAN
            TempDir tempDir = NewTempDir( dirNameTemplate );
            tempDir.Create();
            tempDir.ClearAllFiles();

            actionF( tempDir );

            // make sure to clean up any non-PERMA files
            tempDir.ClearTempFiles();

            return tempDir;
        }


        public TempFile WithNewTempDirAndPermaFile(string dirNameTemplate, string fileNameTemplate, Action<TempFile> actionF)
        {
            TempFile permaFile = null;

            WithNewTempDir( dirNameTemplate, tempDir =>
            {
                permaFile = tempDir.NewPermaFile( fileNameTemplate );
                actionF( permaFile );
                
            });

            return permaFile;
        }


        public TempFile WithNewTempDirAndPermaFileWriteBytes(string dirNameTemplate, string fileNameTemplate, byte[] fileContent)
        {
            TempFile permaFile = WithNewTempDirAndPermaFile(dirNameTemplate, fileNameTemplate, (tmpFile) =>
                                 {
                                     File.WriteAllBytes( tmpFile.FilePath, fileContent );
                                 });
            return permaFile;
        }



        
        /// <summary>
        ///   Cleanup strategy where we delete files and directories in the WorkingDir that are older than N days.
        /// </summary>
        public void ClearDirsAndFilesOlderThanDays(int days)
        {
            if (! Directory.Exists( DirPath ))
                return;

            DateTime currentTime = DateTime.Now;
        
            List<string> filesOlderThanDays = 
                Directory.GetFiles( DirPath )
                         // do not try to delete error log files generated by WorkingDir class
                         .Where( filePath => ! filePath.ToUpper().EndsWith(".LOG.TXT") )
                         .Where( filePath => FileIsOlderThanDays(filePath, days, currentTime) )
                         .ToList();
                                          
            filesOlderThanDays.ForEach( TryDeleteFile );
        
            List<string> dirsOlderThanDays =
                Directory.GetDirectories( DirPath )
                         .Where( dirPath => DirIsOlderThanDays(dirPath, days, currentTime) )
                         .ToList();
        
            dirsOlderThanDays.ForEach( TryDeleteDir );
        
        }
    
    
        bool FileIsOlderThanDays(string filePath, int days, DateTime currentTime)
        {
            bool isOlderThanDays = (currentTime - File.GetCreationTime( filePath )).Days > days;
            return isOlderThanDays;
        }
    
    
        void TryDeleteFile(string filePath)
        {
            try
            {
                if (File.Exists( filePath ))
                    File.Delete( filePath );
            }
            catch (Exception ex)
            {
                // If we cannot delete the file now, we do not want to fail.  We will just try again later.
                // We LOG the fact that something could not be deleted so we can investigate cleanup problems.
                LogDeleteFailure( ex );
            }
        }
    
    
        bool DirIsOlderThanDays(string dirPath, int days, DateTime currentTime)
        {
            bool isOlderThanDays = (currentTime - Directory.GetCreationTime( dirPath )).Days > days;
            return isOlderThanDays;
        }
    
    
        void TryDeleteDir(string dirPath)
        {
            try
            {
                if (Directory.Exists( dirPath ))
                    Directory.Delete( dirPath, true );
            }
            catch (Exception ex)
            {
                // If we cannot delete the directory now, we do not want to fail.  We will just try again later.
                // We LOG the fact that something could not be deleted so we can investigate cleanup problems.
                LogDeleteFailure( ex );
            }
        }


        void LogDeleteFailure(Exception ex)
        {
            string logFile = Path.Combine( DirPath, _dirName + "_WorkingDir_errors.log.txt" );
            string logMsg  = "=========================================================\r\n"
                           + "[" + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss") + "]\r\n"
                           + ex;

            File.AppendAllText(logFile, logMsg);
        }
    }
}
